#include "SecMod.h"
#include "System/Containers/MapList.h"
#include "System/Security/Usm.h"
#include "System/Util/Callback.h"
#include "System/Util/DefaultStore.h"
#include "System/Util/Logger.h"
#include "System/Util/Trace.h"

/** ============================[ Macros ]============================ */

/** try to pick a reasonable security module default
 *  based on what was compiled into the priot package */
#define secmodDEFAULT_MODEL USM_SEC_MODEL_NUMBER

/** ============================[ Private Variables ]================== */

/**  the list of security services */
static struct SecModList_s* _registeredServices = NULL;

/** ==================[ Private Functions Prototypes ]================== */

static Callback_f _SecMod_setDefaultSecMod;

/** =============================[ Public Functions ]================== */

void SecMod_init( void )
{
    Callback_register( CallbackMajor_LIBRARY, CallbackMinor_SESSION_INIT, _SecMod_setDefaultSecMod, NULL );

    DefaultStore_registerConfig( asnOCTET_STR, "priot", "defSecurityModel",
        DsStore_LIBRARY_ID, DsStr_SECMODEL );

    /* This file is automatically generated by configure.  Do not modify by hand. */
    Usm_initUsm();
}

void SecMod_shutdown( void )
{
    /* This file is automatically generated by configure.  Do not modify by hand. */
    Usm_shutdownUsm();
}

int SecMod_register( int secMod, const char* secModName,
    struct SecModDefinition_s* newDef )
{
    int result;
    struct SecModList_s* sptr;
    char* othername;

    for ( sptr = _registeredServices; sptr; sptr = sptr->next ) {
        if ( sptr->securityModel == secMod ) {
            return ErrorCode_GENERR;
        }
    }
    sptr = MEMORY_MALLOC_STRUCT( SecModList_s );

    if ( sptr == NULL )
        return ErrorCode_MALLOC;

    sptr->secModDefinition = newDef;
    sptr->securityModel = secMod;
    sptr->next = _registeredServices;
    _registeredServices = sptr;

    if ( ( result = MapList_addPair( "priotSecmods", String_new( secModName ), secMod ) )
        != MapListErrorCode_SUCCESS ) {
        switch ( result ) {
        case MapListErrorCode_NO_MEMORY:
            Logger_log( LOGGER_PRIORITY_CRIT, "priotSecmod: no memory\n" );
            break;

        case MapListErrorCode_ALREADY_EXIST:
            othername = MapList_findLabel( "priotSecmods", secMod );
            if ( String_compare( othername, secModName ) != StringCompare_EQUAL ) {
                Logger_log( LOGGER_PRIORITY_ERR,
                    "priotSecmod: two security modules %s and %s registered with the same security number\n",
                    secModName, othername );
            }
            break;

        default:
            Logger_log( LOGGER_PRIORITY_ERR,
                "priotSecmod: unknown error trying to register a new security module\n" );
            break;
        }
        return ErrorCode_GENERR;
    }
    return ErrorCode_SUCCESS;
}

int SecMod_unregister( int secmod )
{
    struct SecModList_s *sptr, *lptr;

    for ( sptr = _registeredServices, lptr = NULL; sptr;
          lptr = sptr, sptr = sptr->next ) {
        if ( sptr->securityModel == secmod ) {
            if ( lptr )
                lptr->next = sptr->next;
            else
                _registeredServices = sptr->next;
            MEMORY_FREE( sptr->secModDefinition );
            MEMORY_FREE( sptr );
            return ErrorCode_SUCCESS;
        }
    }
    /*
     * not registered
     */
    return ErrorCode_GENERR;
}

void SecMod_clear( void )
{
    struct SecModList_s *tmp = _registeredServices, *next = NULL;

    while ( tmp != NULL ) {
        next = tmp->next;
        MEMORY_FREE( tmp->secModDefinition );
        MEMORY_FREE( tmp );
        tmp = next;
    }
    _registeredServices = NULL;
}

struct SecModDefinition_s* SecMod_findDefBySecMod( int secMod )
{
    struct SecModList_s* sptr;

    for ( sptr = _registeredServices; sptr; sptr = sptr->next ) {
        if ( sptr->securityModel == secMod ) {
            return sptr->secModDefinition;
        }
    }
    /*
     * not registered
     */
    return NULL;
}

/** =============================[ Private Functions ]================== */

static int _SecMod_setDefaultSecMod( int major, int minor, void* extraArgument, void* callbackFuncArg )
{
    Types_Session* sess = ( Types_Session* )extraArgument;

    char* cptr;
    int model;

    if ( !sess )
        return ErrorCode_GENERR;

    if ( sess->securityModel == API_DEFAULT_SECMODEL ) {
        if ( ( cptr = DefaultStore_getString( DsStore_LIBRARY_ID, DsStr_SECMODEL ) ) != NULL ) {
            if ( ( model = MapList_findValue( "priotSecmods", cptr ) ) != MapListErrorCode_NULL ) {
                sess->securityModel = model;
            } else {
                Logger_log( LOGGER_PRIORITY_ERR, "unknown security model name: %s.  Forcing USM instead.\n", cptr );
                sess->securityModel = secmodDEFAULT_MODEL;
                return ErrorCode_GENERR;
            }
        } else {
            sess->securityModel = secmodDEFAULT_MODEL;
        }
    }
    return ErrorCode_SUCCESS;
}
