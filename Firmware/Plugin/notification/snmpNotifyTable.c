/*
 * This file was generated by mib2c and is intended for use as
 * a mib module for the ucd-snmp snmpd agent.
 */

/*
 * This should always be included first before anything else
 */

#include "snmpNotifyTable.h"
#include "AgentCallbacks.h"
#include "AgentReadConfig.h"
#include "AgentRegistry.h"
#include "System/Util/Callback.h"
#include "Client.h"
#include "Impl.h"
#include "ReadConfig.h"
#include "SysORTable.h"
#include "System/Util/Assert.h"
#include "System/Util/Trace.h"
#include "System/Util/Logger.h"
#include "TextualConvention.h"
#include "Trap.h"
#include "Vacm.h"
#include "VarStruct.h"
#include "header_complex.h"
#include "notification-log-mib/notification_log.h"
#include "snmp-notification-mib/snmpNotifyFilterTable/snmpNotifyFilterTable_data_access.h"
#include "snmpNotifyFilterProfileTable.h"
#include "target/target.h"

#include "PluginSettings.h"

Callback_f store_snmpNotifyTable;

/*
 * snmpNotifyTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid snmpNotifyTable_variables_oid[] = { 1, 3, 6, 1, 6, 3, 13, 1, 1 };

static oid snmpNotifyFullCompliance[] = { PRIOT_OID_SNMPMODULES, 13, 3, 1, 3 }; /* SNMP-NOTIFICATION-MIB::snmpNotifyFullCompliance */

/*
 * Variable2_s snmpNotifyTable_variables:
 *   this variable defines function callbacks and type return information
 *   for the snmpNotifyTable mib section
 */

struct Variable2_s snmpNotifyTable_variables[] = {
/*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix
     */
#define SNMPNOTIFYTAG 4
    { SNMPNOTIFYTAG, ASN01_OCTET_STR, IMPL_OLDAPI_RWRITE,
        var_snmpNotifyTable, 2, { 1, 2 } },
#define SNMPNOTIFYTYPE 5
    { SNMPNOTIFYTYPE, ASN01_INTEGER, IMPL_OLDAPI_RWRITE,
        var_snmpNotifyTable, 2, { 1, 3 } },
#define SNMPNOTIFYSTORAGETYPE 6
    { SNMPNOTIFYSTORAGETYPE, ASN01_INTEGER, IMPL_OLDAPI_RWRITE,
        var_snmpNotifyTable, 2, { 1, 4 } },
#define SNMPNOTIFYROWSTATUS 7
    { SNMPNOTIFYROWSTATUS, ASN01_INTEGER, IMPL_OLDAPI_RWRITE,
        var_snmpNotifyTable, 2, { 1, 5 } },

};
/*
 * (L = length of the oidsuffix)
 */

/*
 * global storage of our data, saved in and configured by header_complex()
 */
static struct header_complex_index* snmpNotifyTableStorage = NULL;

static int
_checkFilter( const char* paramName, Types_Pdu* pdu )
{
    /*
     * find appropriate filterProfileEntry
     */
    VariableList *var, *trap_var;
    char* profileName;
    size_t profileNameLen;
    struct Vacm_ViewEntry_s *vp, *head;
    int vb_oid_excluded = 0;
    extern const oid trap_priotTrapOid[];
    extern const size_t trap_priotTrapOidLen;

    Assert_assert( NULL != paramName );
    Assert_assert( NULL != pdu );

    DEBUG_MSGTL( ( "send_notifications", "checking filters...\n" ) );

    /*
   A notification originator uses the snmpNotifyFilterTable to filter
   notifications.  A notification filter profile may be associated with
   a particular entry in the snmpTargetParamsTable.  The associated
   filter profile is identified by an entry in the
   snmpNotifyFilterProfileTable whose index is equal to the index of the
   entry in the snmpTargetParamsTable.  If no such entry exists in the
   snmpNotifyFilterProfileTable, no filtering is performed for that
   management target.
    */
    profileName = get_FilterProfileName( paramName, strlen( paramName ),
        &profileNameLen );
    if ( NULL == profileName ) {
        DEBUG_MSGTL( ( "send_notifications", "  no matching profile\n" ) );
        return 0;
    }

    /*
   If such an entry does exist, the value of snmpNotifyFilterProfileName
   of the entry is compared with the corresponding portion of the index
   of all active entries in the snmpNotifyFilterTable.  All such entries
   for which this comparison results in an exact match are used for
   filtering a notification generated using the associated
   snmpTargetParamsEntry.  If no such entries exist, no filtering is
   performed, and a notification may be sent to the management target.
    */
    head = snmpNotifyFilterTable_vacm_view_subtree( profileName );
    if ( NULL == head ) {
        DEBUG_MSGTL( ( "send_notifications", "  no matching filters\n" ) );
        return 0;
    }

    /*
   Otherwise, if matching entries do exist, a notification may be sent
   if the NOTIFICATION-TYPE OBJECT IDENTIFIER of the notification (this
   is the value of the element of the variable bindings whose name is
   snmpTrapOID.0, i.e., the second variable binding) is specifically
   included, and none of the object instances to be included in the
   variable-bindings of the notification are specifically excluded by
   the matching entries.
     */
    trap_var = Client_findVarbindInList( pdu->variables,
        trap_priotTrapOid,
        trap_priotTrapOidLen );
    if ( NULL != trap_var ) {
        /*
                             For a notification name, if none match,
   then the notification name is considered excluded, and the
   notification should not be sent to this management target.
         */
        vp = Vacm_viewGet( head, profileName, trap_var->value.objectId,
            trap_var->valueLength / sizeof( oid ), VACM_MODE_FIND );
        if ( ( NULL == vp ) || ( PRIOT_VIEW_INCLUDED != vp->viewType ) ) {
            DEBUG_MSGTL( ( "send_notifications", "  filtered (snmpTrapOID.0 " ) );
            DEBUG_MSGOID( ( "send_notifications", trap_var->value.objectId,
                trap_var->valueLength / sizeof( oid ) ) );
            DEBUG_MSG( ( "send_notifications", " not included)\n" ) );
            free( head );
            return 1;
        }
    }

    /*
     * check varbinds
     */
    for ( var = pdu->variables; var; var = var->next ) {
        /*
                                                               For an
   object instance, if none match, the object instance is considered
   included, and the notification may be sent to this management target.
         */

        if ( var == trap_var ) {
            continue;
        }

        vp = Vacm_viewGet( head, profileName, var->name,
            var->nameLength, VACM_MODE_FIND );
        if ( ( NULL != vp ) && ( PRIOT_VIEW_EXCLUDED == vp->viewType ) ) {
            DEBUG_MSGTL( ( "send_notifications", "  filtered (varbind " ) );
            DEBUG_MSGOID( ( "send_notifications", var->name, var->nameLength ) );
            DEBUG_MSG( ( "send_notifications", " excluded)\n" ) );
            vb_oid_excluded = 1;
            break;
        }
    }

    free( head );

    return vb_oid_excluded;
}

int send_notifications( int major, int minor, void* serverarg, void* clientarg )
{
    struct header_complex_index* hptr;
    struct snmpNotifyTable_data* nptr;
    Types_Session *sess, *sptr;
    Types_Pdu* template_pdu = ( Types_Pdu* )serverarg;
    int count = 0, send = 0;

    DEBUG_MSGTL( ( "send_notifications", "starting: pdu=%p, vars=%p\n",
        template_pdu, template_pdu->variables ) );

    for ( hptr = snmpNotifyTableStorage; hptr; hptr = hptr->next ) {
        nptr = ( struct snmpNotifyTable_data* )hptr->data;
        if ( nptr->snmpNotifyRowStatus != TC_RS_ACTIVE )
            continue;
        if ( !nptr->snmpNotifyTag )
            continue;

        sess = get_target_sessions( nptr->snmpNotifyTag, NULL, NULL );

        /*
         * filter appropriately, per section 6 of RFC 3413
         */

        for ( sptr = sess; sptr; sptr = sptr->next ) {
            send = 0;

            if ( ( sptr->version == PRIOT_VERSION_3

                     )
                && minor == PriotdCallback_SEND_TRAP2 ) {
                if ( nptr->snmpNotifyType == SNMPNOTIFYTYPE_INFORM ) {
                    template_pdu->command = PRIOT_MSG_INFORM;
                } else {
                    template_pdu->command = PRIOT_MSG_TRAP2;
                }
                send = 1;
            }
            if ( send && sess->paramName ) {
                int filter = _checkFilter( sess->paramName, template_pdu );
                if ( filter )
                    send = 0;
            }
            if ( send ) {
                Trap_sendTrapToSess( sptr, template_pdu );
                ++count;
            } /* session to send to */
        } /* for(sptr) */
    } /* for(hptr) */

    DEBUG_MSGTL( ( "send_notifications", "sent %d notifications\n", count ) );

    if ( count )
        log_notification( template_pdu, NULL );

    return 0;
}

#define MAX_ENTRIES 1024

int notifyTable_register_notifications( int major, int minor,
    void* serverarg, void* clientarg )
{
    struct targetAddrTable_struct* ptr;
    struct targetParamTable_struct* pptr;
    struct snmpNotifyTable_data* nptr;
    int confirm, i, bufLen;
    char buf[ UTILITIES_MAX_BUFFER_SMALL ];
    Transport_Transport* t = NULL;
    struct AgentAddTrapArgs_s* args = ( struct AgentAddTrapArgs_s* )serverarg;
    Types_Session* ss;

    if ( !args || !( args->ss ) ) {
        return ( 0 );
    }
    confirm = args->confirm;
    ss = args->ss;

    /*
     * XXX: START move target creation to target code
     */
    for ( i = 0; i < MAX_ENTRIES; i++ ) {
        bufLen = sprintf( buf, "internal%d", i );
        if ( get_addrForName2( buf, bufLen ) == NULL && get_paramEntry( buf ) == NULL )
            break;
    }
    if ( i == MAX_ENTRIES ) {
        Logger_log( LOGGER_PRIORITY_ERR,
            "Can't register new trap destination: max limit reached: %d",
            MAX_ENTRIES );
        Api_sessClose( ss );
        return ( 0 );
    }

    /*
     * address
     */
    t = Api_sessTransport( Api_sessPointer( ss ) );
    if ( !t ) {
        Logger_log( LOGGER_PRIORITY_ERR,
            "Cannot add new trap destination, transport is closed." );
        Api_sessClose( ss );
        return 0;
    }
    ptr = snmpTargetAddrTable_create();
    ptr->nameData = ( char* )Memory_memdup( buf, bufLen );
    ptr->nameLen = bufLen;
    memcpy( ptr->tDomain, t->domain, t->domain_length * sizeof( oid ) );
    ptr->tDomainLen = t->domain_length;
    ptr->tAddressLen = t->remote_length;
    ptr->tAddress = t->remote;

    ptr->timeout = ss->timeout / 10000;
    ptr->retryCount = ss->retries;
    MEMORY_FREE( ptr->tagList );
    ptr->tagList = strdup( buf ); /* strdup ok since buf contains 'internal%d' */
    ptr->params = strdup( buf );
    ptr->storageType = TC_ST_READONLY;
    ptr->rowStatus = TC_RS_ACTIVE;
    ptr->sess = ss;
    DEBUG_MSGTL( ( "trapsess", "adding to trap table\n" ) );
    snmpTargetAddrTable_add( ptr );

    /*
     * param
     */
    pptr = snmpTargetParamTable_create();
    pptr->paramName = strdup( buf );
    pptr->mpModel = ss->version;
    if ( ss->version == PRIOT_VERSION_3 ) {
        pptr->secModel = ss->securityModel;
        pptr->secLevel = ss->securityLevel;
        pptr->secName = ( char* )malloc( ss->securityNameLen + 1 );
        if ( pptr->secName == NULL ) {
            snmpTargetParamTable_dispose( pptr );
            return 0;
        }
        memcpy( ( void* )pptr->secName, ( void* )ss->securityName,
            ss->securityNameLen );
        pptr->secName[ ss->securityNameLen ] = 0;
    }

    pptr->storageType = TC_ST_READONLY;
    pptr->rowStatus = TC_RS_ACTIVE;
    snmpTargetParamTable_add( pptr );
    /*
     * XXX: END move target creation to target code
     */

    /*
     * notify table
     */
    nptr = MEMORY_MALLOC_STRUCT( snmpNotifyTable_data );
    if ( nptr == NULL )
        return 0;
    nptr->snmpNotifyName = strdup( buf );
    nptr->snmpNotifyNameLen = strlen( buf );
    nptr->snmpNotifyTag = strdup( buf );
    nptr->snmpNotifyTagLen = strlen( buf );
    nptr->snmpNotifyType = confirm ? SNMPNOTIFYTYPE_INFORM : SNMPNOTIFYTYPE_TRAP;
    nptr->snmpNotifyStorageType = TC_ST_READONLY;
    nptr->snmpNotifyRowStatus = TC_RS_ACTIVE;

    snmpNotifyTable_add( nptr );
    return 0;
}

/*
 * XXX: this really needs to be done for the target mib entries too.
 * But we can only trust that we've added stuff here and we don't want
 * to destroy other valid entries in the target tables, so...  Don't
 * do too many kill -HUPs to your agent as re reading the config file
 * will be a slow memory leak in the target mib.
 */
int notifyTable_unregister_notifications( int major, int minor,
    void* serverarg, void* clientarg )
{
    struct header_complex_index *hptr, *nhptr;

    for ( hptr = snmpNotifyTableStorage; hptr; hptr = nhptr ) {
        struct snmpNotifyTable_data* nptr = ( struct snmpNotifyTable_data* )hptr->data;
        nhptr = hptr->next;
        if ( nptr->snmpNotifyStorageType == TC_ST_READONLY ) {
            header_complex_extract_entry( &snmpNotifyTableStorage, hptr );
            free( nptr->snmpNotifyName );
            free( nptr->snmpNotifyTag );
            free( nptr );
        }
    }
    snmpNotifyTableStorage = NULL;
    return ( 0 );
}

/*
 * init_snmpNotifyTable():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void init_snmpNotifyTable( void )
{
    DEBUG_MSGTL( ( "snmpNotifyTable", "initializing...  " ) );

    /*
     * register ourselves with the agent to handle our mib tree
     */
    REGISTER_MIB( "snmpNotifyTable", snmpNotifyTable_variables, Variable2_s,
        snmpNotifyTable_variables_oid );

    /*
     * register our config handler(s) to deal with registrations
     */
    AgentReadConfig_priotdRegisterConfigHandler( "snmpNotifyTable", parse_snmpNotifyTable,
        NULL, NULL );

    /*
     * we need to be called back later to store our data
     */
    Callback_register( CallbackMajor_LIBRARY, CallbackMinor_STORE_DATA,
        store_snmpNotifyTable, NULL );

    Callback_register( CallbackMajor_APPLICATION,
        PriotdCallback_SEND_TRAP2, send_notifications,
        NULL );
    Callback_register( CallbackMajor_APPLICATION,
        PriotdCallback_REGISTER_NOTIFICATIONS,
        notifyTable_register_notifications, NULL );
    Callback_register( CallbackMajor_APPLICATION,
        PriotdCallback_PRE_UPDATE_CONFIG,
        notifyTable_unregister_notifications, NULL );

    /*
     * place any other initialization junk you need here
     */

    REGISTER_SYSOR_ENTRY( snmpNotifyFullCompliance,
        "The MIB modules for managing SNMP Notification, plus filtering." );

    DEBUG_MSGTL( ( "snmpNotifyTable", "done.\n" ) );
}

void shutdown_snmpNotifyTable( void )
{
    DEBUG_MSGTL( ( "snmpNotifyTable", "shutting down ... " ) );

    notifyTable_unregister_notifications( CallbackMajor_APPLICATION,
        PriotdCallback_PRE_UPDATE_CONFIG,
        NULL,
        NULL );

    Callback_unregister( CallbackMajor_APPLICATION,
        PriotdCallback_PRE_UPDATE_CONFIG,
        notifyTable_unregister_notifications, NULL, FALSE );
    Callback_unregister( CallbackMajor_APPLICATION,
        PriotdCallback_REGISTER_NOTIFICATIONS,
        notifyTable_register_notifications, NULL, FALSE );
    Callback_unregister( CallbackMajor_APPLICATION,
        PriotdCallback_SEND_TRAP2, send_notifications,
        NULL, FALSE );

    Callback_unregister( CallbackMajor_LIBRARY, CallbackMinor_STORE_DATA,
        store_snmpNotifyTable, NULL, FALSE );

    UNREGISTER_SYSOR_ENTRY( snmpNotifyFullCompliance );

    DEBUG_MSGTL( ( "snmpNotifyTable", "done.\n" ) );
}

/*
 * snmpNotifyTable_add(): adds a structure node to our data set
 */
int snmpNotifyTable_add( struct snmpNotifyTable_data* thedata )
{
    VariableList* vars = NULL;
    int retVal;

    DEBUG_MSGTL( ( "snmpNotifyTable", "adding data...  " ) );
    /*
     * add the index variables to the varbind list, which is
     * used by header_complex to index the data
     */

    Api_varlistAddVariable( &vars, NULL, 0, ASN01_PRIV_IMPLIED_OCTET_STR, ( u_char* )thedata->snmpNotifyName, thedata->snmpNotifyNameLen ); /* snmpNotifyName */

    if ( header_complex_maybe_add_data( &snmpNotifyTableStorage, vars, thedata, 1 )
        != NULL ) {
        DEBUG_MSGTL( ( "snmpNotifyTable", "registered an entry\n" ) );
        retVal = ErrorCode_SUCCESS;
    } else {
        retVal = ErrorCode_GENERR;
    }

    DEBUG_MSGTL( ( "snmpNotifyTable", "done.\n" ) );
    return retVal;
}

/*
 * parse_snmpNotifyTable():
 *   parses .conf file entries needed to configure the mib.
 */
void parse_snmpNotifyTable( const char* token, char* line )
{
    size_t tmpint;
    struct snmpNotifyTable_data* StorageTmp = MEMORY_MALLOC_STRUCT( snmpNotifyTable_data );

    DEBUG_MSGTL( ( "snmpNotifyTable", "parsing config...  " ) );

    if ( StorageTmp == NULL ) {
        ReadConfig_configPerror( "malloc failure" );
        return;
    }

    line = ReadConfig_readData( ASN01_OCTET_STR, line,
        &StorageTmp->snmpNotifyName,
        &StorageTmp->snmpNotifyNameLen );
    if ( StorageTmp->snmpNotifyName == NULL ) {
        ReadConfig_configPerror( "invalid specification for snmpNotifyName" );
        MEMORY_FREE( StorageTmp );
        return;
    }

    line = ReadConfig_readData( ASN01_OCTET_STR, line,
        &StorageTmp->snmpNotifyTag,
        &StorageTmp->snmpNotifyTagLen );
    if ( StorageTmp->snmpNotifyTag == NULL ) {
        ReadConfig_configPerror( "invalid specification for snmpNotifyTag" );
        MEMORY_FREE( StorageTmp );
        return;
    }

    line = ReadConfig_readData( ASN01_INTEGER, line,
        &StorageTmp->snmpNotifyType, &tmpint );

    line = ReadConfig_readData( ASN01_INTEGER, line,
        &StorageTmp->snmpNotifyStorageType, &tmpint );
    if ( !StorageTmp->snmpNotifyStorageType )
        StorageTmp->snmpNotifyStorageType = TC_ST_READONLY;

    line = ReadConfig_readData( ASN01_INTEGER, line,
        &StorageTmp->snmpNotifyRowStatus, &tmpint );
    if ( !StorageTmp->snmpNotifyRowStatus )
        StorageTmp->snmpNotifyRowStatus = TC_RS_ACTIVE;

    if ( snmpNotifyTable_add( StorageTmp ) != ErrorCode_SUCCESS ) {
        MEMORY_FREE( StorageTmp->snmpNotifyName );
        MEMORY_FREE( StorageTmp->snmpNotifyTag );
        MEMORY_FREE( StorageTmp );
    }

    DEBUG_MSGTL( ( "snmpNotifyTable", "done.\n" ) );
}

/*
 * store_snmpNotifyTable():
 *   stores .conf file entries needed to configure the mib.
 */
int store_snmpNotifyTable( int majorID, int minorID, void* serverarg,
    void* clientarg )
{
    char line[ UTILITIES_MAX_BUFFER ];
    char* cptr;
    size_t tmpint;
    struct snmpNotifyTable_data* StorageTmp;
    struct header_complex_index* hcindex;

    DEBUG_MSGTL( ( "snmpNotifyTable", "storing data...  " ) );

    for ( hcindex = snmpNotifyTableStorage; hcindex != NULL;
          hcindex = hcindex->next ) {
        StorageTmp = ( struct snmpNotifyTable_data* )hcindex->data;

        /*
         * store permanent and nonvolatile rows.
         * XXX should there be a qualification on RowStatus??
         */
        if ( ( StorageTmp->snmpNotifyStorageType == TC_ST_NONVOLATILE ) || ( StorageTmp->snmpNotifyStorageType == TC_ST_PERMANENT ) ) {

            memset( line, 0, sizeof( line ) );
            strcat( line, "snmpNotifyTable " );
            cptr = line + strlen( line );

            cptr = ReadConfig_storeData( ASN01_OCTET_STR, cptr,
                &StorageTmp->snmpNotifyName,
                &StorageTmp->snmpNotifyNameLen );
            cptr = ReadConfig_storeData( ASN01_OCTET_STR, cptr,
                &StorageTmp->snmpNotifyTag,
                &StorageTmp->snmpNotifyTagLen );
            cptr = ReadConfig_storeData( ASN01_INTEGER, cptr,
                &StorageTmp->snmpNotifyType,
                &tmpint );
            cptr = ReadConfig_storeData( ASN01_INTEGER, cptr,
                &StorageTmp->snmpNotifyStorageType,
                &tmpint );
            cptr = ReadConfig_storeData( ASN01_INTEGER, cptr,
                &StorageTmp->snmpNotifyRowStatus,
                &tmpint );

            AgentReadConfig_priotdStoreConfig( line );
        }
    }
    DEBUG_MSGTL( ( "snmpNotifyTable", "done.\n" ) );
    return 0;
}

/*
 * var_snmpNotifyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_snmpNotifyTable above.
 */
unsigned char*
var_snmpNotifyTable( struct Variable_s* vp,
    oid* name,
    size_t* length,
    int exact,
    size_t* var_len, WriteMethodFT** write_method )
{
    struct snmpNotifyTable_data* StorageTmp = NULL;
    int found = 1;

    DEBUG_MSGTL( ( "snmpNotifyTable",
        "var_snmpNotifyTable: Entering...  \n" ) );
    /*
     * this assumes you have registered all your data properly
     */
    if ( ( StorageTmp = ( struct snmpNotifyTable_data* )
                 header_complex( ( struct header_complex_index* )
                                     snmpNotifyTableStorage,
                     vp, name, length, exact,
                     var_len, write_method ) )
        == NULL ) {
        found = 0;
    }

    switch ( vp->magic ) {
    case SNMPNOTIFYTAG:
        *write_method = write_snmpNotifyTag;
        break;
    case SNMPNOTIFYTYPE:
        *write_method = write_snmpNotifyType;
        break;
    case SNMPNOTIFYSTORAGETYPE:
        *write_method = write_snmpNotifyStorageType;
        break;
    case SNMPNOTIFYROWSTATUS:
        *write_method = write_snmpNotifyRowStatus;
        break;
    default:
        *write_method = NULL;
    }

    if ( !found ) {
        return NULL;
    }

    switch ( vp->magic ) {
    case SNMPNOTIFYTAG:
        *var_len = StorageTmp->snmpNotifyTagLen;
        return ( u_char* )StorageTmp->snmpNotifyTag;

    case SNMPNOTIFYTYPE:
        *var_len = sizeof( StorageTmp->snmpNotifyType );
        return ( u_char* )&StorageTmp->snmpNotifyType;

    case SNMPNOTIFYSTORAGETYPE:
        *var_len = sizeof( StorageTmp->snmpNotifyStorageType );
        return ( u_char* )&StorageTmp->snmpNotifyStorageType;

    case SNMPNOTIFYROWSTATUS:
        *var_len = sizeof( StorageTmp->snmpNotifyRowStatus );
        return ( u_char* )&StorageTmp->snmpNotifyRowStatus;

    default:
        IMPL_ERROR_MSG( "" );
    }
    return NULL;
}

static int
is_delim( const char c )
{
    return ( c == 0x020 || c == 0x09 || c == 0x0d || c == 0x0b );
}

int snmpTagValid( const char* tag, const size_t tagLen )
{
    size_t i = 0;

    for ( i = 0; i < tagLen; i++ ) {
        if ( is_delim( tag[ i ] ) ) {
            /*
             * Delimeters aren't allowed.
             */
            return 0;
        }
    }
    return 1;
}

static struct snmpNotifyTable_data* StorageNew;

int write_snmpNotifyTag( int action,
    u_char* var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char* statP, oid* name, size_t name_len )
{
    static char* tmpvar;
    struct snmpNotifyTable_data* StorageTmp = NULL;
    static size_t tmplen;
    size_t newlen = name_len - ( sizeof( snmpNotifyTable_variables_oid ) / sizeof( oid ) + 3 - 1 );

    DEBUG_MSGTL( ( "snmpNotifyTable",
        "write_snmpNotifyTag entering action=%d...  \n", action ) );
    if ( action != IMPL_RESERVE1 && ( StorageTmp = ( struct snmpNotifyTable_data* )header_complex( ( struct header_complex_index* )snmpNotifyTableStorage, NULL, &name[ sizeof( snmpNotifyTable_variables_oid ) / sizeof( oid ) + 3 - 1 ], &newlen, 1, NULL, NULL ) ) == NULL ) {
        if ( ( StorageTmp = StorageNew ) == NULL )
            return PRIOT_ERR_NOSUCHNAME; /* remove if you support creation here */
    }

    switch ( action ) {
    case IMPL_RESERVE1:
        if ( var_val_type != ASN01_OCTET_STR ) {
            return PRIOT_ERR_WRONGTYPE;
        }
        if ( var_val_len > 255 ) {
            return PRIOT_ERR_WRONGLENGTH;
        }
        if ( !snmpTagValid( ( char* )var_val, var_val_len ) ) {
            return PRIOT_ERR_WRONGVALUE;
        }
        break;

    case IMPL_RESERVE2:
        /*
         * memory reseveration, final preparation...
         */
        tmpvar = StorageTmp->snmpNotifyTag;
        tmplen = StorageTmp->snmpNotifyTagLen;
        StorageTmp->snmpNotifyTag = ( char* )calloc( 1, var_val_len + 1 );
        if ( NULL == StorageTmp->snmpNotifyTag )
            return PRIOT_ERR_RESOURCEUNAVAILABLE;
        break;

    case IMPL_FREE:
        /*
         * Release any resources that have been allocated
         */
        break;

    case IMPL_ACTION:
        memcpy( StorageTmp->snmpNotifyTag, var_val, var_val_len );
        StorageTmp->snmpNotifyTagLen = var_val_len;
        break;

    case IMPL_UNDO:
        /*
         * Back out any changes made in the IMPL_ACTION case
         */
        MEMORY_FREE( StorageTmp->snmpNotifyTag );
        StorageTmp->snmpNotifyTag = tmpvar;
        StorageTmp->snmpNotifyTagLen = tmplen;
        tmpvar = NULL;
        break;

    case IMPL_COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        MEMORY_FREE( tmpvar );
        Api_storeNeeded( NULL );
        break;
    }

    return PRIOT_ERR_NOERROR;
}

int write_snmpNotifyType( int action,
    u_char* var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char* statP, oid* name, size_t name_len )
{
    static int tmpvar;
    struct snmpNotifyTable_data* StorageTmp = NULL;
    long value = *( ( long* )var_val );
    size_t newlen = name_len - ( sizeof( snmpNotifyTable_variables_oid ) / sizeof( oid ) + 3 - 1 );

    DEBUG_MSGTL( ( "snmpNotifyTable",
        "write_snmpNotifyType entering action=%d...  \n", action ) );
    if ( action != IMPL_RESERVE1 && ( StorageTmp = ( struct snmpNotifyTable_data* )header_complex( ( struct header_complex_index* )snmpNotifyTableStorage, NULL, &name[ sizeof( snmpNotifyTable_variables_oid ) / sizeof( oid ) + 3 - 1 ], &newlen, 1, NULL, NULL ) ) == NULL ) {
        if ( ( StorageTmp = StorageNew ) == NULL )
            return PRIOT_ERR_NOSUCHNAME;
    }

    switch ( action ) {
    case IMPL_RESERVE1:
        if ( var_val_type != ASN01_INTEGER ) {
            return PRIOT_ERR_WRONGTYPE;
        }
        if ( var_val_len != sizeof( long ) ) {
            return PRIOT_ERR_WRONGLENGTH;
        }
        if ( value < 1 || value > 2 ) {
            return PRIOT_ERR_WRONGVALUE;
        }
        break;

    case IMPL_ACTION:
        tmpvar = StorageTmp->snmpNotifyType;
        StorageTmp->snmpNotifyType = value;
        break;

    case IMPL_UNDO:
        /*
         * Back out any changes made in the IMPL_ACTION case
         */
        StorageTmp->snmpNotifyType = tmpvar;
        break;
    }

    return PRIOT_ERR_NOERROR;
}

int write_snmpNotifyStorageType( int action,
    u_char* var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char* statP, oid* name, size_t name_len )
{
    static int tmpvar;
    long value = *( ( long* )var_val );
    struct snmpNotifyTable_data* StorageTmp = NULL;
    size_t newlen = name_len - ( sizeof( snmpNotifyTable_variables_oid ) / sizeof( oid ) + 3 - 1 );

    DEBUG_MSGTL( ( "snmpNotifyTable",
        "write_snmpNotifyStorageType entering action=%d...  \n",
        action ) );
    if ( action != IMPL_RESERVE1 && ( StorageTmp = ( struct snmpNotifyTable_data* )header_complex( ( struct header_complex_index* )snmpNotifyTableStorage, NULL, &name[ sizeof( snmpNotifyTable_variables_oid ) / sizeof( oid ) + 3 - 1 ], &newlen, 1, NULL, NULL ) ) == NULL ) {
        if ( ( StorageTmp = StorageNew ) == NULL )
            return PRIOT_ERR_NOSUCHNAME;
    }

    switch ( action ) {
    case IMPL_RESERVE1:
        if ( var_val_type != ASN01_INTEGER ) {
            return PRIOT_ERR_WRONGTYPE;
        }
        if ( var_val_len != sizeof( long ) ) {
            return PRIOT_ERR_WRONGLENGTH;
        }
        if ( value != PRIOT_STORAGE_OTHER && value != PRIOT_STORAGE_VOLATILE
            && value != PRIOT_STORAGE_NONVOLATILE ) {
            return PRIOT_ERR_WRONGVALUE;
        }
        break;

    case IMPL_ACTION:
        tmpvar = StorageTmp->snmpNotifyStorageType;
        StorageTmp->snmpNotifyStorageType = value;
        break;

    case IMPL_UNDO:
        StorageTmp->snmpNotifyStorageType = tmpvar;
        break;
    }
    return PRIOT_ERR_NOERROR;
}

int write_snmpNotifyRowStatus( int action,
    u_char* var_val,
    u_char var_val_type,
    size_t var_val_len,
    u_char* statP, oid* name, size_t name_len )
{
    struct snmpNotifyTable_data* StorageTmp = NULL;
    static struct snmpNotifyTable_data* StorageDel;
    size_t newlen = name_len - ( sizeof( snmpNotifyTable_variables_oid ) / sizeof( oid ) + 3 - 1 );
    static int old_value;
    int set_value = *( ( long* )var_val );
    static VariableList *vars, *vp;
    struct header_complex_index* hciptr;

    DEBUG_MSGTL( ( "snmpNotifyTable",
        "write_snmpNotifyRowStatus entering action=%d...  \n",
        action ) );
    StorageTmp = ( struct snmpNotifyTable_data* )
        header_complex( ( struct header_complex_index* )
                            snmpNotifyTableStorage,
            NULL,
            &name[ sizeof( snmpNotifyTable_variables_oid ) / sizeof( oid ) + 3 - 1 ], &newlen, 1, NULL, NULL );

    switch ( action ) {
    case IMPL_RESERVE1:
        if ( var_val_type != ASN01_INTEGER || var_val == NULL ) {
            return PRIOT_ERR_WRONGTYPE;
        }
        if ( var_val_len != sizeof( long ) ) {
            return PRIOT_ERR_WRONGLENGTH;
        }
        if ( set_value < 1 || set_value > 6 || set_value == TC_RS_NOTREADY ) {
            return PRIOT_ERR_WRONGVALUE;
        }
        if ( StorageTmp == NULL ) {
            /*
             * create the row now?
             */
            /*
             * ditch illegal values now
             */
            if ( set_value == TC_RS_ACTIVE || set_value == TC_RS_NOTINSERVICE ) {
                return PRIOT_ERR_INCONSISTENTVALUE;
            }
        } else {
            /*
             * row exists.  Check for a valid state change
             */
            if ( set_value == TC_RS_CREATEANDGO
                || set_value == TC_RS_CREATEANDWAIT ) {
                /*
                 * can't create a row that exists
                 */
                return PRIOT_ERR_INCONSISTENTVALUE;
            }
            /*
             * XXX: interaction with row storage type needed
             */
        }

        /*
         * memory reseveration, final preparation...
         */
        if ( StorageTmp == NULL && ( set_value == TC_RS_CREATEANDGO
                                       || set_value == TC_RS_CREATEANDWAIT ) ) {
            /*
             * creation
             */
            vars = NULL;

            Api_varlistAddVariable( &vars, NULL, 0, ASN01_PRIV_IMPLIED_OCTET_STR, NULL, 0 ); /* snmpNotifyName */

            if ( header_complex_parse_oid( &( name
                                                   [ sizeof( snmpNotifyTable_variables_oid ) / sizeof( oid ) + 2 ] ),
                     newlen, vars )
                != ErrorCode_SUCCESS ) {
                /*
                 * XXX: free, zero vars
                 */
                Api_freeVar( vars );
                return PRIOT_ERR_INCONSISTENTNAME;
            }
            vp = vars;

            StorageNew = MEMORY_MALLOC_STRUCT( snmpNotifyTable_data );
            if ( StorageNew == NULL ) {
                return PRIOT_ERR_RESOURCEUNAVAILABLE;
            }
            StorageNew->snmpNotifyName = ( char* )calloc( 1, vp->valueLength + 1 );
            if ( StorageNew->snmpNotifyName == NULL ) {
                return PRIOT_ERR_RESOURCEUNAVAILABLE;
            }
            memcpy( StorageNew->snmpNotifyName, vp->value.string, vp->valueLength );
            StorageNew->snmpNotifyNameLen = vp->valueLength;
            vp = vp->next;

            /*
             * default values
             */
            StorageNew->snmpNotifyStorageType = TC_ST_NONVOLATILE;
            StorageNew->snmpNotifyType = SNMPNOTIFYTYPE_TRAP;
            StorageNew->snmpNotifyTagLen = 0;
            StorageNew->snmpNotifyTag = ( char* )calloc( sizeof( char ), 1 );
            if ( StorageNew->snmpNotifyTag == NULL ) {
                return PRIOT_ERR_RESOURCEUNAVAILABLE;
            }

            StorageNew->snmpNotifyRowStatus = set_value;
            Api_freeVar( vars );
        }
        break;

    case IMPL_RESERVE2:
        break;

    case IMPL_FREE:
        if ( StorageNew != NULL ) {
            MEMORY_FREE( StorageNew->snmpNotifyTag );
            MEMORY_FREE( StorageNew->snmpNotifyName );
            free( StorageNew );
            StorageNew = NULL;
        }
        break;

    case IMPL_ACTION:
        if ( StorageTmp == NULL && ( set_value == TC_RS_CREATEANDGO || set_value == TC_RS_CREATEANDWAIT ) ) {
            /*
             * row creation, so add it
             */
            if ( StorageNew != NULL ) {
                snmpNotifyTable_add( StorageNew );
            }
        } else if ( set_value != TC_RS_DESTROY ) {
            /*
             * set the flag?
             */
            if ( StorageTmp == NULL )
                return PRIOT_ERR_GENERR; /* should never ever get here */

            old_value = StorageTmp->snmpNotifyRowStatus;
            StorageTmp->snmpNotifyRowStatus = *( ( long* )var_val );
        } else {
            /*
             * destroy...  extract it for now
             */
            if ( StorageTmp ) {
                hciptr = header_complex_find_entry( snmpNotifyTableStorage,
                    StorageTmp );
                StorageDel = ( struct snmpNotifyTable_data* )
                    header_complex_extract_entry( ( struct
                                                      header_complex_index** )&snmpNotifyTableStorage,
                        hciptr );
            }
        }
        break;

    case IMPL_UNDO:
        /*
         * Back out any changes made in the IMPL_ACTION case
         */
        if ( StorageTmp == NULL && ( set_value == TC_RS_CREATEANDGO || set_value == TC_RS_CREATEANDWAIT ) ) {
            /*
             * row creation, so remove it again
             */
            hciptr = header_complex_find_entry( snmpNotifyTableStorage,
                StorageNew );
            StorageDel = ( struct snmpNotifyTable_data* )
                header_complex_extract_entry( ( struct header_complex_index** )&snmpNotifyTableStorage,
                    hciptr );
            /*
             * XXX: free it
             */
        } else if ( StorageDel != NULL ) {
            /*
             * row deletion, so add it again
             */
            snmpNotifyTable_add( StorageDel );
        } else if ( set_value != TC_RS_DESTROY ) {
            if ( StorageTmp )
                StorageTmp->snmpNotifyRowStatus = old_value;
        }
        break;

    case IMPL_COMMIT:
        if ( StorageDel != NULL ) {
            MEMORY_FREE( StorageDel->snmpNotifyTag );
            MEMORY_FREE( StorageDel->snmpNotifyName );
            free( StorageDel );
            StorageDel = NULL;
        }
        if ( StorageTmp
            && StorageTmp->snmpNotifyRowStatus == TC_RS_CREATEANDGO ) {
            StorageTmp->snmpNotifyRowStatus = TC_RS_ACTIVE;
            StorageNew = NULL;
        } else if ( StorageTmp && StorageTmp->snmpNotifyRowStatus == TC_RS_CREATEANDWAIT ) {
            StorageTmp->snmpNotifyRowStatus = TC_RS_NOTINSERVICE;
            StorageNew = NULL;
        }
        Api_storeNeeded( NULL );
        break;
    }
    return PRIOT_ERR_NOERROR;
}
