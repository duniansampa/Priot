/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.container.conf,v 1.8 2006/07/26 15:58:26 dts12 Exp $
 */
/* Portions of this file are subject to the following copyright(s).  See
 * the Net-SNMP's COPYING file for more details and other copyrights
 * that may apply:
 */
/*
 * Portions of this file are copyrighted by:
 * Copyright (C) 2007 Apple, Inc. All rights reserved.
 * Use is subject to license terms specified in the COPYING file
 * distributed with the Net-SNMP package.
 */

#include "hrSWInstalledTable.h"
#include "System/Util/Assert.h"
#include "CacheHandler.h"
#include "Client.h"
#include "System/Util/Trace.h"
#include "System/Util/Logger.h"
#include "Table.h"
#include "TableContainer.h"
#include "Vars.h"
#include "siglog/data_access/swinst.h"

#define MYTABLE "hrSWInstalledTable"

static TableRegistrationInfo* table_info;

static void _cache_free( Cache* cache, void* magic );
static int _cache_load( Cache* cache, void* magic );

/** Initializes the hrSWInstalledTable module */
void init_hrSWInstalledTable( void )
{
    /*
     * here we initialize all the tables we're planning on supporting 
     */
    initialize_table_hrSWInstalledTable();
}

void shutdown_hrSWInstalledTable( void )
{
    if ( table_info ) {
        Table_registrationInfoFree( table_info );
        table_info = NULL;
    }
}

/** Initialize the hrSWInstalledTable table by defining its contents and how it's structured */
void initialize_table_hrSWInstalledTable( void )
{
    static oid hrSWInstalledTable_oid[] = { 1, 3, 6, 1, 2, 1, 25, 6, 3 };
    size_t hrSWInstalledTable_oid_len = ASN01_OID_LENGTH( hrSWInstalledTable_oid );
    HandlerRegistration* reg;
    MibHandler* handler = NULL;
    Container_Container* container = NULL;
    Cache* cache = NULL;

    DEBUG_MSGTL( ( "hrSWInstalled", "initialize\n" ) );

    reg = AgentHandler_createHandlerRegistration( "hrSWInstalledTable",
        hrSWInstalledTable_handler,
        hrSWInstalledTable_oid,
        hrSWInstalledTable_oid_len,
        HANDLER_CAN_RONLY );
    if ( NULL == reg ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error creating handler registration for " MYTABLE "\n" );
        goto bail;
    }

    container = Container_find( "hrSWInstalledTable:tableContainer" );
    if ( NULL == container ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error creating container for " MYTABLE "\n" );
        goto bail;
    }

    table_info = MEMORY_MALLOC_TYPEDEF( TableRegistrationInfo );
    if ( NULL == table_info ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error allocating table registration for " MYTABLE "\n" );
        goto bail;
    }

    Table_helperAddIndexes( table_info, ASN01_INTEGER, /* index: hrSWInstalledIndex */
        0 );
    table_info->min_column = COLUMN_HRSWINSTALLEDINDEX;
    table_info->max_column = COLUMN_HRSWINSTALLEDDATE;

    /*************************************************
     *
     * inject container_table helper
     */
    handler = TableContainer_handlerGet( table_info, container,
        TABLE_CONTAINER_KEY_NETSNMP_INDEX );
    if ( NULL == handler ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error allocating table registration for " MYTABLE "\n" );
        goto bail;
    }
    if ( ErrorCode_SUCCESS != AgentHandler_injectHandler( reg, handler ) ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error injecting container_table handler for " MYTABLE "\n" );
        goto bail;
    }
    handler = NULL; /* reg has it, will reuse below */

    /*************************************************
     *
     * inject cache helper
     */
    cache = CacheHandler_create( 30, /* timeout in seconds */
        _cache_load, _cache_free,
        hrSWInstalledTable_oid,
        hrSWInstalledTable_oid_len );

    if ( NULL == cache ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error creating cache for " MYTABLE "\n" );
        goto bail;
    }
    cache->magic = container;

    handler = CacheHandler_handlerGet( cache );
    if ( NULL == handler ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error creating cache handler for " MYTABLE "\n" );
        goto bail;
    }
    if ( ErrorCode_SUCCESS != AgentHandler_injectHandler( reg, handler ) ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error injecting cache handler for " MYTABLE "\n" );
        goto bail;
    }
    handler = NULL; /* reg has it*/

    if ( ErrorCode_SUCCESS != Table_registerTable( reg, table_info ) ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error registering table handler for " MYTABLE "\n" );
        reg = NULL; /* it was freed inside Table_registerTable */
        goto bail;
    }

    return; /* ok */

bail: /* not ok */

    if ( handler )
        AgentHandler_handlerFree( handler );

    if ( cache )
        CacheHandler_free( cache );

    if ( table_info )
        Table_registrationInfoFree( table_info );

    if ( container )
        CONTAINER_FREE( container );

    if ( reg )
        AgentHandler_handlerRegistrationFree( reg );
}

/** handles requests for the hrSWInstalledTable table */
int hrSWInstalledTable_handler( MibHandler* handler,
    HandlerRegistration* reginfo,
    AgentRequestInfo* reqinfo,
    RequestInfo* requests )
{

    RequestInfo* request;
    TableRequestInfo* table_info;
    netsnmp_swinst_entry* table_entry;

    switch ( reqinfo->mode ) {
    /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for ( request = requests; request; request = request->next ) {
            if ( request->processed )
                continue;
            table_entry = ( netsnmp_swinst_entry* )
                TableContainer_extractContext( request );
            table_info = Table_extractTableInfo( request );
            if ( ( NULL == table_entry ) || ( NULL == table_info ) ) {
                Logger_log( LOGGER_PRIORITY_ERR, "could not extract table entry or info for " MYTABLE "\n" );
                Client_setVarTypedValue( request->requestvb,
                    PRIOT_ERR_GENERR, NULL, 0 );
                continue;
            }

            switch ( table_info->colnum ) {
            case COLUMN_HRSWINSTALLEDINDEX:
                Client_setVarTypedInteger( request->requestvb, ASN01_INTEGER,
                    table_entry->swIndex );
                break;
            case COLUMN_HRSWINSTALLEDNAME: {
                Client_setVarTypedValue( request->requestvb, ASN01_OCTET_STR,
                    ( u_char* )table_entry->swName,
                    table_entry->swName_len );
            } break;
            case COLUMN_HRSWINSTALLEDID:
                Client_setVarTypedValue( request->requestvb, ASN01_OBJECT_ID,
                    ( u_char* )&vars_nullOid, vars_nullOidLen );
                break;
            case COLUMN_HRSWINSTALLEDTYPE:
                Client_setVarTypedInteger( request->requestvb, ASN01_INTEGER,
                    table_entry->swType );
                break;
            case COLUMN_HRSWINSTALLEDDATE:
                Client_setVarTypedValue( request->requestvb, ASN01_OCTET_STR,
                    ( u_char* )table_entry->swDate,
                    table_entry->swDate_len );
                break;
            default:
                /*
                 * An unsupported/unreadable column (if applicable) 
                 */
                Client_setVarTypedValue( request->requestvb,
                    PRIOT_NOSUCHOBJECT, NULL, 0 );
            }
        }
        break;
    }
    return PRIOT_ERR_NOERROR;
}

/***********************************************************************
 *
 * DATA ACCESS
 *
 * The data access mechanism here is rather simple: let newsnmp_swinst_*
 * take care of it.
 ***********************************************************************/
/**
 * @internal
 */
static int
_cache_load( Cache* cache, void* vmagic )
{
    DEBUG_MSGTL( ( "hrSWInstalledTable:cache", "load\n" ) );

    if ( ( NULL == cache ) || ( NULL == cache->magic ) ) {
        Logger_log( LOGGER_PRIORITY_ERR, "invalid cache for hrSWInstalledTable_cache_load\n" );
        return -1;
    }

    /** should only be called for an invalid or expired cache */
    Assert_assert( ( 0 == cache->valid ) || ( 1 == cache->expired ) );

    cache->magic = netsnmp_swinst_container_load( ( Container_Container* )cache->magic, 0 );

    return 0;
} /* _cache_load */

/**
 * @internal
 */
static void
_cache_free( Cache* cache, void* magic )
{
    if ( ( NULL == cache ) || ( NULL == cache->magic ) ) {
        Logger_log( LOGGER_PRIORITY_ERR, "invalid cache in hrSWInstalledTable_cache_free\n" );
        return;
    }
    DEBUG_MSGTL( ( "hrSWInstalledTable:cache", "free\n" ) );

    netsnmp_swinst_container_free_items( ( Container_Container* )cache->magic );
} /* _cache_free */
