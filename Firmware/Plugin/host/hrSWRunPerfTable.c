/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.container.conf,v 1.8 2006/07/26 15:58:26 dts12 Exp $
 */
/* Portions of this file are subject to the following copyright(s).  See
 * the Net-SNMP's COPYING file for more details and other copyrights
 * that may apply:
 */
/*
 * Portions of this file are copyrighted by:
 * Copyright (C) 2007 Apple, Inc. All rights reserved.
 * Use is subject to license terms specified in the COPYING file
 * distributed with the Net-SNMP package.
 */

#include "hrSWRunPerfTable.h"
#include "Client.h"
#include "System/Util/Logger.h"
#include "Table.h"
#include "TableContainer.h"
#include "data_access/swrun.h"
#include "siglog/data_access/swrun.h"

#define MYTABLE "hrSWRunPerfTable"

/** Initializes the hrSWRunPerfTable module */
void init_hrSWRunPerfTable( void )
{
    /*
     * here we initialize all the tables we're planning on supporting 
     */
    initialize_table_hrSWRunPerfTable();
}

void shutdown_hrSWRunPerfTable( void )
{
    shutdown_table_hrSWRunPerfTable();
}

extern oid hrSWRunTable_oid[];
extern size_t hrSWRunTable_oid_len;
static TableRegistrationInfo* table_info;

/** Initialize the hrSWRunPerfTable table by defining its contents and how it's structured */
void initialize_table_hrSWRunPerfTable( void )
{
    static oid hrSWRunPerfTable_oid[] = { 1, 3, 6, 1, 2, 1, 25, 5, 1 };
    size_t hrSWRunPerfTable_oid_len = asnOID_LENGTH( hrSWRunPerfTable_oid );
    HandlerRegistration* reg;
    MibHandler* handler = NULL;

    reg = AgentHandler_createHandlerRegistration( "hrSWRunPerfTable",
        hrSWRunPerfTable_handler,
        hrSWRunPerfTable_oid,
        hrSWRunPerfTable_oid_len,
        HANDLER_CAN_RONLY );
    if ( NULL == reg ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error creating handler registration for " MYTABLE "\n" );
        goto bail;
    }

    table_info = MEMORY_MALLOC_TYPEDEF( TableRegistrationInfo );
    if ( NULL == table_info ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error allocating table registration for " MYTABLE "\n" );
        goto bail;
    }
    Table_helperAddIndexes( table_info, asnINTEGER, /* index: hrSWRunIndex */
        0 );
    table_info->min_column = COLUMN_HRSWRUNPERFCPU;
    table_info->max_column = COLUMN_HRSWRUNPERFMEM;

    /*************************************************
     *
     * inject container_table helper
     */
    handler = TableContainer_handlerGet( table_info, netsnmp_swrun_container(),
        TABLE_CONTAINER_KEY_NETSNMP_INDEX );
    if ( NULL == handler ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error allocating table registration for " MYTABLE "\n" );
        goto bail;
    }
    if ( ErrorCode_SUCCESS != AgentHandler_injectHandler( reg, handler ) ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error injecting container_table handler for " MYTABLE "\n" );
        goto bail;
    }
    handler = NULL; /* reg has it, will reuse below */

    /*************************************************
     *
     * inject cache helper
     */

    handler = CacheHandler_handlerGet( netsnmp_swrun_cache() );
    if ( NULL == handler ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error creating cache handler for " MYTABLE "\n" );
        goto bail;
    }

    if ( ErrorCode_SUCCESS != AgentHandler_injectHandler( reg, handler ) ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error injecting cache handler for " MYTABLE "\n" );
        goto bail;
    }
    handler = NULL; /* reg has it*/

    if ( ErrorCode_SUCCESS != Table_registerTable( reg, table_info ) ) {
        Logger_log( LOGGER_PRIORITY_ERR, "error registering table handler for " MYTABLE "\n" );
        reg = NULL; /* it was freed inside Table_registerTable */
        goto bail;
    }

    return; /* ok */

bail: /* not ok */

    if ( handler )
        AgentHandler_handlerFree( handler );

    if ( table_info )
        Table_registrationInfoFree( table_info );

    if ( reg )
        AgentHandler_handlerRegistrationFree( reg );
}

void shutdown_table_hrSWRunPerfTable( void )
{
    if ( table_info ) {
        Table_registrationInfoFree( table_info );
        table_info = NULL;
    }
}

/** handles requests for the hrSWRunPerfTable table */
int hrSWRunPerfTable_handler( MibHandler* handler,
    HandlerRegistration* reginfo,
    AgentRequestInfo* reqinfo,
    RequestInfo* requests )
{

    RequestInfo* request;
    TableRequestInfo* table_info;
    netsnmp_swrun_entry* table_entry;

    switch ( reqinfo->mode ) {
    /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for ( request = requests; request; request = request->next ) {
            if ( request->processed )
                continue;
            table_entry = ( netsnmp_swrun_entry* )
                TableContainer_extractContext( request );
            table_info = Table_extractTableInfo( request );
            if ( ( NULL == table_entry ) || ( NULL == table_info ) ) {
                Logger_log( LOGGER_PRIORITY_ERR, "could not extract table entry or info for " MYTABLE "\n" );
                Client_setVarTypedValue( request->requestvb,
                    PRIOT_ERR_GENERR, NULL, 0 );
                continue;
            }

            switch ( table_info->colnum ) {
            case COLUMN_HRSWRUNPERFCPU:
                Client_setVarTypedInteger( request->requestvb, asnINTEGER,
                    table_entry->hrSWRunPerfCPU );
                break;
            case COLUMN_HRSWRUNPERFMEM:
                Client_setVarTypedInteger( request->requestvb, asnINTEGER,
                    table_entry->hrSWRunPerfMem );
                break;
            default:
                /*
                 * An unsupported/unreadable column (if applicable) 
                 */
                Client_setVarTypedValue( request->requestvb,
                    PRIOT_NOSUCHOBJECT, NULL, 0 );
            }
        }
        break;
    }
    return PRIOT_ERR_NOERROR;
}
