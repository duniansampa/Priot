/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.iterate.conf,v 1.5 2001/12/04 21:36:27 hardaker Exp $
 */

#include "nsModuleTable.h"
#include "AgentRegistry.h"
#include "Client.h"
#include "System/Util/Trace.h"
#include "System/Util/Logger.h"
#include "VarStruct.h"

void nsModuleTable_free( void* context, IteratorInfo* dont_care )
{
    free( context );
}

/** Initialize the nsModuleTable table by defining it's contents and how it's structured */
void initialize_table_nsModuleTable( void )
{
    const oid nsModuleTable_oid[] = { 1, 3, 6, 1, 4, 1, 8072, 1, 2, 1 };
    TableRegistrationInfo* table_info;
    HandlerRegistration* my_handler;
    IteratorInfo* iinfo;

    /*
     * create the table structure itself 
     */
    table_info = MEMORY_MALLOC_TYPEDEF( TableRegistrationInfo );
    iinfo = MEMORY_MALLOC_TYPEDEF( IteratorInfo );

    /*
     * if your table is read only, it's easiest to change the
     * HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY 
     */
    my_handler = AgentHandler_createHandlerRegistration( "nsModuleTable",
        nsModuleTable_handler,
        nsModuleTable_oid,
        ASN01_OID_LENGTH( nsModuleTable_oid ),
        HANDLER_CAN_RWRITE );

    if ( !my_handler || !table_info || !iinfo ) {
        if ( my_handler )
            AgentHandler_handlerRegistrationFree( my_handler );
        MEMORY_FREE( table_info );
        MEMORY_FREE( iinfo );
        return; /* mallocs failed */
    }

    /***************************************************
     * Setting up the table's definition
     */
    Table_helperAddIndexes( table_info, ASN01_OCTET_STR, /* context name */
        ASN01_OBJECT_ID, /* reg point */
        ASN01_INTEGER, /* priority */
        0 );

    table_info->min_column = 4;
    table_info->max_column = 6;

    /*
     * iterator access routines 
     */
    iinfo->get_first_data_point = nsModuleTable_get_first_data_point;
    iinfo->get_next_data_point = nsModuleTable_get_next_data_point;
    iinfo->free_loop_context_at_end = nsModuleTable_free;
    iinfo->table_reginfo = table_info;

    /***************************************************
     * registering the table with the master agent
     */
    DEBUG_MSGTL( ( "initialize_table_nsModuleTable",
        "Registering table nsModuleTable as a table iterator\n" ) );
    TableIterator_registerTableIterator2( my_handler, iinfo );
}

/** Initializes the nsModuleTable module */
void init_nsModuleTable( void )
{

    /*
     * here we initialize all the tables we're planning on supporting 
     */
    initialize_table_nsModuleTable();
}

/** returns the first data point within the nsModuleTable table data.

    Set the my_loop_context variable to the first data point structure
    of your choice (from which you can find the next one).  This could
    be anything from the first node in a linked list, to an integer
    pointer containing the beginning of an array variable.

    Set the my_data_context variable to something to be returned to
    you later that will provide you with the data to return in a given
    row.  This could be the same pointer as what my_loop_context is
    set to, or something different.

    The put_index_data variable contains a list of snmp variable
    bindings, one for each index in your table.  Set the values of
    each appropriately according to the data matching the first row
    and return the put_index_data variable at the end of the function.
*/
typedef struct context_tree_ptr_s {
    Subtree* tree;
    SubtreeContextCache* context_ptr;
} context_tree_ptr;

VariableList*
nsModuleTable_get_first_data_point( void** my_loop_context,
    void** my_data_context,
    VariableList* put_index_data,
    IteratorInfo* otherstuff )
{

    struct VariableList_s* vptr;
    u_long ultmp;
    context_tree_ptr* ctree;

    ctree = MEMORY_MALLOC_TYPEDEF( context_tree_ptr );

    ctree->context_ptr = AgentRegistry_getTopContextCache();
    /* Skip empty context registrations */
    while ( !ctree->context_ptr->first_subtree ) {
        ctree->context_ptr = ctree->context_ptr->next;
        if ( !ctree->context_ptr ) {
            MEMORY_FREE( ctree );
            return NULL;
        }
    }
    ctree->tree = ctree->context_ptr->first_subtree;

    *my_loop_context = ctree;
    *my_data_context = ctree->tree;

    vptr = put_index_data;
    Client_setVarValue( vptr, ctree->context_ptr->context_name,
        strlen( ctree->context_ptr->context_name ) );

    vptr = vptr->next;
    Client_setVarValue( vptr,
        ctree->context_ptr->first_subtree->name_a,
        ctree->context_ptr->first_subtree->namelen * sizeof( oid ) );

    ultmp = ctree->context_ptr->first_subtree->priority;
    vptr = vptr->next;
    Client_setVarValue( vptr, &ultmp, sizeof( ultmp ) );

    return put_index_data;
}

/** functionally the same as nsModuleTable_get_first_data_point, but
   my_loop_context has already been set to a previous value and should
   be updated to the next in the list.  For example, if it was a
   linked list, you might want to cast it and the return
   my_loop_context->next.  The my_data_context pointer should be set
   to something you need later and the indexes in put_index_data
   updated again. */

struct VariableList_s*
nsModuleTable_get_next_data_point( void** my_loop_context,
    void** my_data_context,
    struct VariableList_s* put_index_data,
    IteratorInfo* otherstuff )
{

    struct VariableList_s* vptr;
    context_tree_ptr* ctree = ( context_tree_ptr* )*my_loop_context;
    u_long ultmp;

    if ( ctree->tree->next )
        ctree->tree = ctree->tree->next;
    else {
        ctree->context_ptr = ctree->context_ptr->next;
        if ( !ctree->context_ptr ) {
            return NULL;
        }
        ctree->tree = ctree->context_ptr->first_subtree;
    }

    *my_data_context = ctree->tree;

    vptr = put_index_data;
    Client_setVarValue( vptr, ctree->context_ptr->context_name,
        strlen( ctree->context_ptr->context_name ) );

    vptr = vptr->next;
    Client_setVarValue( vptr, ctree->tree->name_a,
        ctree->tree->namelen * sizeof( oid ) );

    ultmp = ctree->tree->priority;
    vptr = vptr->next;
    Client_setVarValue( vptr, &ultmp, sizeof( ultmp ) );

    return put_index_data;
}

/** handles requests for the nsModuleTable table, if anything else needs to be done */
int nsModuleTable_handler( MibHandler* handler,
    HandlerRegistration* reginfo,
    AgentRequestInfo* reqinfo,
    RequestInfo* requests )
{

    TableRequestInfo* table_info;
    RequestInfo* request;
    VariableList* var;
    Subtree* tree;
    u_long ultmp;
    u_char modes[ 1 ];

    for ( request = requests; request; request = request->next ) {
        var = request->requestvb;
        if ( request->processed != 0 )
            continue;

        /*
         * perform anything here that you need to do.  The request have
         * already been processed by the master table_dataset handler, but
         * this gives you chance to act on the request in some other way if 
         * need be. 
         */

        /*
         * the following extracts the my_data_context pointer set in the
         * loop functions above.  You can then use the results to help
         * return data for the columns of the nsModuleTable table in
         * question 
         */
        tree = ( Subtree* )TableIterator_extractIteratorContext( request );
        if ( tree == NULL ) {
            if ( reqinfo->mode == MODE_GET ) {
                Agent_setRequestError( reqinfo, request,
                    PRIOT_NOSUCHINSTANCE );
                continue;
            }
            /*
             * XXX: no row existed, if you support creation and this is a
             * set, start dealing with it here, else continue 
             */
        }

        /*
         * extracts the information about the table from the request 
         */
        table_info = Table_extractTableInfo( request );

        /*
         * table_info->colnum contains the column number requested 
         */
        /*
         * table_info->indexes contains a linked list of snmp variable
         * bindings for the indexes of the table.  Values in the list have 
         * been set corresponding to the indexes of the request 
         */
        if ( table_info == NULL ) {
            continue;
        }

        switch ( reqinfo->mode ) {
        /*
             * the table_iterator helper should change all GETNEXTs into
             * GETs for you automatically, so you don't have to worry
             * about the GETNEXT case.  Only GETs and SETs need to be
             * dealt with here 
             */
        case MODE_GET:
            switch ( table_info->colnum ) {
            case COLUMN_NSMODULENAME:
                if ( tree->reginfo->handlerName ) {
                    Client_setVarTypedValue( var, ASN01_OCTET_STR,
                        tree->reginfo->handlerName,
                        strlen( tree->reginfo->handlerName ) );
                } else {
                    Client_setVarTypedValue( var, ASN01_OCTET_STR, "", 0 );
                }
                break;

            case COLUMN_NSMODULEMODES:
                /*
                 * basically, these BITS needs to be inverted in order 
                 */
                modes[ 0 ] = ( ( HANDLER_CAN_GETANDGETNEXT & tree->reginfo->modes ) << 7 ) | ( ( HANDLER_CAN_SET & tree->reginfo->modes ) << 5 ) | ( ( HANDLER_CAN_GETBULK
                                                                                                                                                         & tree->reginfo->modes )
                                                                                                                                                       << 3 );
                /*  yuck  */
                Client_setVarTypedValue( var, ASN01_OCTET_STR, modes, 1 );
                break;

            case COLUMN_NSMODULETIMEOUT:
                ultmp = tree->timeout;
                Client_setVarTypedValue( var, ASN01_INTEGER,
                    ( u_char* )&ultmp,
                    sizeof( u_long ) );
                break;

            default:
                /*
                 * We shouldn't get here 
                 */
                Logger_log( LOGGER_PRIORITY_ERR,
                    "problem encountered in nsModuleTable_handler: unknown column\n" );
            }
            break;

        default:
            Logger_log( LOGGER_PRIORITY_ERR,
                "problem encountered in nsModuleTable_handler: unsupported mode\n" );
        }
    }
    return PRIOT_ERR_NOERROR;
}
